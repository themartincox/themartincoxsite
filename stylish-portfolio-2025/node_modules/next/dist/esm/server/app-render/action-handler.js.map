{"version":3,"sources":["../../../src/server/app-render/action-handler.ts"],"sourcesContent":["import type { IncomingHttpHeaders, OutgoingHttpHeaders } from 'http'\nimport type { SizeLimit } from '../../types'\nimport type { RequestStore } from '../app-render/work-unit-async-storage.external'\nimport type { AppRenderContext, GenerateFlight } from './app-render'\nimport type { AppPageModule } from '../route-modules/app-page/module'\nimport type { BaseNextRequest, BaseNextResponse } from '../base-http'\nimport type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\n\nimport {\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  ACTION_HEADER,\n} from '../../client/components/app-router-headers'\nimport {\n  getAccessFallbackHTTPStatus,\n  isHTTPAccessFallbackError,\n} from '../../client/components/http-access-fallback/http-access-fallback'\nimport {\n  getRedirectTypeFromError,\n  getURLFromRedirectError,\n} from '../../client/components/redirect'\nimport {\n  isRedirectError,\n  type RedirectType,\n} from '../../client/components/redirect-error'\nimport RenderResult from '../render-result'\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport { FlightRenderResult } from './flight-render-result'\nimport {\n  filterReqHeaders,\n  actionsForbiddenHeaders,\n} from '../lib/server-ipc/utils'\nimport {\n  appendMutableCookies,\n  getModifiedCookieValues,\n} from '../web/spec-extension/adapters/request-cookies'\n\nimport {\n  NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n  NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n} from '../../lib/constants'\nimport { getServerActionRequestMetadata } from '../lib/server-action-request-meta'\nimport { isCsrfOriginAllowed } from './csrf-protection'\nimport { warn } from '../../build/output/log'\nimport { RequestCookies, ResponseCookies } from '../web/spec-extension/cookies'\nimport { HeadersAdapter } from '../web/spec-extension/adapters/headers'\nimport { fromNodeOutgoingHttpHeaders } from '../web/utils'\nimport { selectWorkerForForwarding } from './action-utils'\nimport { isNodeNextRequest, isWebNextRequest } from '../base-http/helpers'\nimport { RedirectStatusCode } from '../../client/components/redirect-status-code'\nimport { synchronizeMutableCookies } from '../async-storage/request-store'\nimport type { TemporaryReferenceSet } from 'react-server-dom-webpack/server.edge'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\n\n/**\n * Checks if the app has any server actions defined in any runtime.\n */\nfunction hasServerActions(manifest: ActionManifest) {\n  return (\n    Object.keys(manifest.node).length > 0 ||\n    Object.keys(manifest.edge).length > 0\n  )\n}\n\nfunction nodeHeadersToRecord(\n  headers: IncomingHttpHeaders | OutgoingHttpHeaders\n) {\n  const record: Record<string, string> = {}\n  for (const [key, value] of Object.entries(headers)) {\n    if (value !== undefined) {\n      record[key] = Array.isArray(value) ? value.join(', ') : `${value}`\n    }\n  }\n  return record\n}\n\nfunction getForwardedHeaders(\n  req: BaseNextRequest,\n  res: BaseNextResponse\n): Headers {\n  // Get request headers and cookies\n  const requestHeaders = req.headers\n  const requestCookies = new RequestCookies(HeadersAdapter.from(requestHeaders))\n\n  // Get response headers and cookies\n  const responseHeaders = res.getHeaders()\n  const responseCookies = new ResponseCookies(\n    fromNodeOutgoingHttpHeaders(responseHeaders)\n  )\n\n  // Merge request and response headers\n  const mergedHeaders = filterReqHeaders(\n    {\n      ...nodeHeadersToRecord(requestHeaders),\n      ...nodeHeadersToRecord(responseHeaders),\n    },\n    actionsForbiddenHeaders\n  ) as Record<string, string>\n\n  // Merge cookies into requestCookies, so responseCookies always take precedence\n  // and overwrite/delete those from requestCookies.\n  responseCookies.getAll().forEach((cookie) => {\n    if (typeof cookie.value === 'undefined') {\n      requestCookies.delete(cookie.name)\n    } else {\n      requestCookies.set(cookie)\n    }\n  })\n\n  // Update the 'cookie' header with the merged cookies\n  mergedHeaders['cookie'] = requestCookies.toString()\n\n  // Remove headers that should not be forwarded\n  delete mergedHeaders['transfer-encoding']\n\n  return new Headers(mergedHeaders)\n}\n\nasync function addRevalidationHeader(\n  res: BaseNextResponse,\n  {\n    workStore,\n    requestStore,\n  }: {\n    workStore: WorkStore\n    requestStore: RequestStore\n  }\n) {\n  await Promise.all([\n    workStore.incrementalCache?.revalidateTag(workStore.revalidatedTags || []),\n    ...Object.values(workStore.pendingRevalidates || {}),\n    ...(workStore.pendingRevalidateWrites || []),\n  ])\n\n  // If a tag was revalidated, the client router needs to invalidate all the\n  // client router cache as they may be stale. And if a path was revalidated, the\n  // client needs to invalidate all subtrees below that path.\n\n  // To keep the header size small, we use a tuple of\n  // [[revalidatedPaths], isTagRevalidated ? 1 : 0, isCookieRevalidated ? 1 : 0]\n  // instead of a JSON object.\n\n  // TODO-APP: Currently the prefetch cache doesn't have subtree information,\n  // so we need to invalidate the entire cache if a path was revalidated.\n  // TODO-APP: Currently paths are treated as tags, so the second element of the tuple\n  // is always empty.\n\n  const isTagRevalidated = workStore.revalidatedTags?.length ? 1 : 0\n  const isCookieRevalidated = getModifiedCookieValues(\n    requestStore.mutableCookies\n  ).length\n    ? 1\n    : 0\n\n  res.setHeader(\n    'x-action-revalidated',\n    JSON.stringify([[], isTagRevalidated, isCookieRevalidated])\n  )\n}\n\n/**\n * Forwards a server action request to a separate worker. Used when the requested action is not available in the current worker.\n */\nasync function createForwardedActionResponse(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  host: Host,\n  workerPathname: string,\n  basePath: string,\n  workStore: WorkStore\n) {\n  if (!host) {\n    throw new Error(\n      'Invariant: Missing `host` header from a forwarded Server Actions request.'\n    )\n  }\n\n  const forwardedHeaders = getForwardedHeaders(req, res)\n\n  // indicate that this action request was forwarded from another worker\n  // we use this to skip rendering the flight tree so that we don't update the UI\n  // with the response from the forwarded worker\n  forwardedHeaders.set('x-action-forwarded', '1')\n\n  const proto = workStore.incrementalCache?.requestProtocol || 'https'\n\n  // For standalone or the serverful mode, use the internal origin directly\n  // other than the host headers from the request.\n  const origin = process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${host.value}`\n\n  const fetchUrl = new URL(`${origin}${basePath}${workerPathname}`)\n\n  try {\n    let body: BodyInit | ReadableStream<Uint8Array> | undefined\n    if (\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME === 'edge' &&\n      isWebNextRequest(req)\n    ) {\n      if (!req.body) {\n        throw new Error('Invariant: missing request body.')\n      }\n\n      body = req.body\n    } else if (\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      isNodeNextRequest(req)\n    ) {\n      body = req.stream()\n    } else {\n      throw new Error('Invariant: Unknown request type.')\n    }\n\n    // Forward the request to the new worker\n    const response = await fetch(fetchUrl, {\n      method: 'POST',\n      body,\n      duplex: 'half',\n      headers: forwardedHeaders,\n      redirect: 'manual',\n      next: {\n        // @ts-ignore\n        internal: 1,\n      },\n    })\n\n    if (\n      response.headers.get('content-type')?.startsWith(RSC_CONTENT_TYPE_HEADER)\n    ) {\n      // copy the headers from the redirect response to the response we're sending\n      for (const [key, value] of response.headers) {\n        if (!actionsForbiddenHeaders.includes(key)) {\n          res.setHeader(key, value)\n        }\n      }\n\n      return new FlightRenderResult(response.body!)\n    } else {\n      // Since we aren't consuming the response body, we cancel it to avoid memory leaks\n      response.body?.cancel()\n    }\n  } catch (err) {\n    // we couldn't stream the forwarded response, so we'll just return an empty response\n    console.error(`failed to forward action response`, err)\n  }\n\n  return RenderResult.fromStatic('{}')\n}\n\n/**\n * Returns the parsed redirect URL if we deem that it is hosted by us.\n *\n * We handle both relative and absolute redirect URLs.\n *\n * In case the redirect URL is not relative to the application we return `null`.\n */\nfunction getAppRelativeRedirectUrl(\n  basePath: string,\n  host: Host,\n  redirectUrl: string\n): URL | null {\n  if (redirectUrl.startsWith('/') || redirectUrl.startsWith('.')) {\n    // Make sure we are appending the basePath to relative URLS\n    return new URL(`${basePath}${redirectUrl}`, 'http://n')\n  }\n\n  const parsedRedirectUrl = new URL(redirectUrl)\n\n  if (host?.value !== parsedRedirectUrl.host) {\n    return null\n  }\n\n  // At this point the hosts are the same, just confirm we\n  // are routing to a path underneath the `basePath`\n  return parsedRedirectUrl.pathname.startsWith(basePath)\n    ? parsedRedirectUrl\n    : null\n}\n\nasync function createRedirectRenderResult(\n  req: BaseNextRequest,\n  res: BaseNextResponse,\n  originalHost: Host,\n  redirectUrl: string,\n  redirectType: RedirectType,\n  basePath: string,\n  workStore: WorkStore\n) {\n  res.setHeader('x-action-redirect', `${redirectUrl};${redirectType}`)\n\n  // If we're redirecting to another route of this Next.js application, we'll\n  // try to stream the response from the other worker path. When that works,\n  // we can save an extra roundtrip and avoid a full page reload.\n  // When the redirect URL starts with a `/` or is to the same host, under the\n  // `basePath` we treat it as an app-relative redirect;\n  const appRelativeRedirectUrl = getAppRelativeRedirectUrl(\n    basePath,\n    originalHost,\n    redirectUrl\n  )\n\n  if (appRelativeRedirectUrl) {\n    if (!originalHost) {\n      throw new Error(\n        'Invariant: Missing `host` header from a forwarded Server Actions request.'\n      )\n    }\n\n    const forwardedHeaders = getForwardedHeaders(req, res)\n    forwardedHeaders.set(RSC_HEADER, '1')\n\n    const proto = workStore.incrementalCache?.requestProtocol || 'https'\n\n    // For standalone or the serverful mode, use the internal origin directly\n    // other than the host headers from the request.\n    const origin =\n      process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${originalHost.value}`\n\n    const fetchUrl = new URL(\n      `${origin}${appRelativeRedirectUrl.pathname}${appRelativeRedirectUrl.search}`\n    )\n\n    if (workStore.revalidatedTags) {\n      forwardedHeaders.set(\n        NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n        workStore.revalidatedTags.join(',')\n      )\n      forwardedHeaders.set(\n        NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n        workStore.incrementalCache?.prerenderManifest?.preview?.previewModeId ||\n          ''\n      )\n    }\n\n    // Ensures that when the path was revalidated we don't return a partial response on redirects\n    forwardedHeaders.delete(NEXT_ROUTER_STATE_TREE_HEADER)\n    // When an action follows a redirect, it's no longer handling an action: it's just a normal RSC request\n    // to the requested URL. We should remove the `next-action` header so that it's not treated as an action\n    forwardedHeaders.delete(ACTION_HEADER)\n\n    try {\n      const response = await fetch(fetchUrl, {\n        method: 'GET',\n        headers: forwardedHeaders,\n        next: {\n          // @ts-ignore\n          internal: 1,\n        },\n      })\n\n      if (\n        response.headers\n          .get('content-type')\n          ?.startsWith(RSC_CONTENT_TYPE_HEADER)\n      ) {\n        // copy the headers from the redirect response to the response we're sending\n        for (const [key, value] of response.headers) {\n          if (!actionsForbiddenHeaders.includes(key)) {\n            res.setHeader(key, value)\n          }\n        }\n\n        return new FlightRenderResult(response.body!)\n      } else {\n        // Since we aren't consuming the response body, we cancel it to avoid memory leaks\n        response.body?.cancel()\n      }\n    } catch (err) {\n      // we couldn't stream the redirect response, so we'll just do a normal redirect\n      console.error(`failed to get redirect response`, err)\n    }\n  }\n\n  return RenderResult.fromStatic('{}')\n}\n\n// Used to compare Host header and Origin header.\nconst enum HostType {\n  XForwardedHost = 'x-forwarded-host',\n  Host = 'host',\n}\ntype Host =\n  | {\n      type: HostType.XForwardedHost\n      value: string\n    }\n  | {\n      type: HostType.Host\n      value: string\n    }\n  | undefined\n\n/**\n * Ensures the value of the header can't create long logs.\n */\nfunction limitUntrustedHeaderValueForLogs(value: string) {\n  return value.length > 100 ? value.slice(0, 100) + '...' : value\n}\n\ntype ServerModuleMap = Record<\n  string,\n  {\n    id: string\n    chunks: string[]\n    name: string\n  }\n>\n\ntype ServerActionsConfig = {\n  bodySizeLimit?: SizeLimit\n  allowedOrigins?: string[]\n}\n\nexport async function handleAction({\n  req,\n  res,\n  ComponentMod,\n  serverModuleMap,\n  generateFlight,\n  workStore,\n  requestStore,\n  serverActions,\n  ctx,\n}: {\n  req: BaseNextRequest\n  res: BaseNextResponse\n  ComponentMod: AppPageModule\n  serverModuleMap: ServerModuleMap\n  generateFlight: GenerateFlight\n  workStore: WorkStore\n  requestStore: RequestStore\n  serverActions?: ServerActionsConfig\n  ctx: AppRenderContext\n}): Promise<\n  | undefined\n  | {\n      type: 'not-found'\n    }\n  | {\n      type: 'done'\n      result: RenderResult | undefined\n      formState?: any\n    }\n> {\n  const contentType = req.headers['content-type']\n  const { serverActionsManifest, page } = ctx.renderOpts\n\n  const {\n    actionId,\n    isURLEncodedAction,\n    isMultipartAction,\n    isFetchAction,\n    isServerAction,\n  } = getServerActionRequestMetadata(req)\n\n  // If it's not a Server Action, skip handling.\n  if (!isServerAction) {\n    return\n  }\n\n  // We don't currently support URL encoded actions, so we bail out early.\n  // Depending on if it's a fetch action or an MPA, we return a different response.\n  if (isURLEncodedAction) {\n    if (isFetchAction) {\n      return {\n        type: 'not-found',\n      }\n    } else {\n      // This is an MPA action, so we return\n      return\n    }\n  }\n\n  // If the app has no server actions at all, we can 404 early.\n  if (!hasServerActions(serverActionsManifest)) {\n    const error = getActionNotFoundError(actionId)\n    console.warn(error)\n\n    return {\n      type: 'not-found',\n    }\n  }\n\n  if (workStore.isStaticGeneration) {\n    throw new Error(\n      \"Invariant: server actions can't be handled during static rendering\"\n    )\n  }\n\n  let temporaryReferences: TemporaryReferenceSet | undefined\n\n  const finalizeAndGenerateFlight: GenerateFlight = (...args) => {\n    // When we switch to the render phase, cookies() will return\n    // `workUnitStore.cookies` instead of `workUnitStore.userspaceMutableCookies`.\n    // We want the render to see any cookie writes that we performed during the action,\n    // so we need to update the immutable cookies to reflect the changes.\n    synchronizeMutableCookies(requestStore)\n    requestStore.phase = 'render'\n    return generateFlight(...args)\n  }\n\n  requestStore.phase = 'action'\n\n  // When running actions the default is no-store, you can still `cache: 'force-cache'`\n  workStore.fetchCache = 'default-no-store'\n\n  const originDomain =\n    typeof req.headers['origin'] === 'string'\n      ? new URL(req.headers['origin']).host\n      : undefined\n\n  const forwardedHostHeader = req.headers['x-forwarded-host'] as\n    | string\n    | undefined\n  const hostHeader = req.headers['host']\n  const host: Host = forwardedHostHeader\n    ? {\n        type: HostType.XForwardedHost,\n        value: forwardedHostHeader,\n      }\n    : hostHeader\n      ? {\n          type: HostType.Host,\n          value: hostHeader,\n        }\n      : undefined\n\n  let warning: string | undefined = undefined\n\n  function warnBadServerActionRequest() {\n    if (warning) {\n      warn(warning)\n    }\n  }\n  // This is to prevent CSRF attacks. If `x-forwarded-host` is set, we need to\n  // ensure that the request is coming from the same host.\n  if (!originDomain) {\n    // This might be an old browser that doesn't send `host` header. We ignore\n    // this case.\n    warning = 'Missing `origin` header from a forwarded Server Actions request.'\n  } else if (!host || originDomain !== host.value) {\n    // If the customer sets a list of allowed origins, we'll allow the request.\n    // These are considered safe but might be different from forwarded host set\n    // by the infra (i.e. reverse proxies).\n    if (isCsrfOriginAllowed(originDomain, serverActions?.allowedOrigins)) {\n      // Ignore it\n    } else {\n      if (host) {\n        // This seems to be an CSRF attack. We should not proceed the action.\n        console.error(\n          `\\`${\n            host.type\n          }\\` header with value \\`${limitUntrustedHeaderValueForLogs(\n            host.value\n          )}\\` does not match \\`origin\\` header with value \\`${limitUntrustedHeaderValueForLogs(\n            originDomain\n          )}\\` from a forwarded Server Actions request. Aborting the action.`\n        )\n      } else {\n        // This is an attack. We should not proceed the action.\n        console.error(\n          `\\`x-forwarded-host\\` or \\`host\\` headers are not provided. One of these is needed to compare the \\`origin\\` header from a forwarded Server Actions request. Aborting the action.`\n        )\n      }\n\n      const error = new Error('Invalid Server Actions request.')\n\n      if (isFetchAction) {\n        res.statusCode = 500\n        await Promise.all([\n          workStore.incrementalCache?.revalidateTag(\n            workStore.revalidatedTags || []\n          ),\n          ...Object.values(workStore.pendingRevalidates || {}),\n          ...(workStore.pendingRevalidateWrites || []),\n        ])\n\n        const promise = Promise.reject(error)\n        try {\n          // we need to await the promise to trigger the rejection early\n          // so that it's already handled by the time we call\n          // the RSC runtime. Otherwise, it will throw an unhandled\n          // promise rejection error in the renderer.\n          await promise\n        } catch {\n          // swallow error, it's gonna be handled on the client\n        }\n\n        return {\n          type: 'done',\n          result: await finalizeAndGenerateFlight(req, ctx, requestStore, {\n            actionResult: promise,\n            // if the page was not revalidated, we can skip the rendering the flight tree\n            skipFlight: !workStore.pathWasRevalidated,\n            temporaryReferences,\n          }),\n        }\n      }\n\n      throw error\n    }\n  }\n\n  // ensure we avoid caching server actions unexpectedly\n  res.setHeader(\n    'Cache-Control',\n    'no-cache, no-store, max-age=0, must-revalidate'\n  )\n\n  let boundActionArguments: unknown[] = []\n\n  const { actionAsyncStorage } = ComponentMod\n\n  let actionResult: RenderResult | undefined\n  let formState: any | undefined\n  let actionModId: string | undefined\n  const actionWasForwarded = Boolean(req.headers['x-action-forwarded'])\n\n  if (actionId) {\n    const forwardedWorker = selectWorkerForForwarding(\n      actionId,\n      page,\n      serverActionsManifest\n    )\n\n    // If forwardedWorker is truthy, it means there isn't a worker for the action\n    // in the current handler, so we forward the request to a worker that has the action.\n    if (forwardedWorker) {\n      return {\n        type: 'done',\n        result: await createForwardedActionResponse(\n          req,\n          res,\n          host,\n          forwardedWorker,\n          ctx.renderOpts.basePath,\n          workStore\n        ),\n      }\n    }\n  }\n\n  try {\n    await actionAsyncStorage.run({ isAction: true }, async () => {\n      if (\n        // The type check here ensures that `req` is correctly typed, and the\n        // environment variable check provides dead code elimination.\n        process.env.NEXT_RUNTIME === 'edge' &&\n        isWebNextRequest(req)\n      ) {\n        if (!req.body) {\n          throw new Error('invariant: Missing request body.')\n        }\n\n        // TODO: add body limit\n\n        // Use react-server-dom-webpack/server.edge\n        const {\n          createTemporaryReferenceSet,\n          decodeReply,\n          decodeAction,\n          decodeFormState,\n        } = ComponentMod\n\n        temporaryReferences = createTemporaryReferenceSet()\n\n        if (isMultipartAction) {\n          // TODO-APP: Add streaming support\n          const formData = await req.request.formData()\n          if (isFetchAction) {\n            try {\n              actionModId = getActionModIdOrError(actionId, serverModuleMap)\n            } catch (err) {\n              console.warn(err)\n\n              return {\n                type: 'not-found',\n              }\n            }\n\n            boundActionArguments = await decodeReply(\n              formData,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          } else {\n            if (areAllActionIdsValid(formData, serverModuleMap) === false) {\n              // TODO: This can be from skew or manipulated input. We should handle this case\n              // more gracefully but this preserves the prior behavior where decodeAction would throw instead.\n              throw new Error(\n                `Failed to find Server Action. This request might be from an older or newer deployment.\\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n              )\n            }\n\n            const action = await decodeAction(formData, serverModuleMap)\n            if (typeof action === 'function') {\n              // Only warn if it's a server action, otherwise skip for other post requests\n              warnBadServerActionRequest()\n              const actionReturnedState = await action()\n              formState = decodeFormState(\n                actionReturnedState,\n                formData,\n                serverModuleMap\n              )\n            }\n\n            // Skip the fetch path\n            return\n          }\n        } else {\n          try {\n            actionModId = getActionModIdOrError(actionId, serverModuleMap)\n          } catch (err) {\n            if (actionId !== null) {\n              console.error(err)\n            }\n            return {\n              type: 'not-found',\n            }\n          }\n\n          let actionData = ''\n\n          const reader = req.body.getReader()\n          while (true) {\n            const { done, value } = await reader.read()\n            if (done) {\n              break\n            }\n\n            actionData += new TextDecoder().decode(value)\n          }\n\n          boundActionArguments = await decodeReply(\n            actionData,\n            serverModuleMap,\n            { temporaryReferences }\n          )\n        }\n      } else if (\n        // The type check here ensures that `req` is correctly typed, and the\n        // environment variable check provides dead code elimination.\n        process.env.NEXT_RUNTIME !== 'edge' &&\n        isNodeNextRequest(req)\n      ) {\n        // Use react-server-dom-webpack/server.node which supports streaming\n        const {\n          createTemporaryReferenceSet,\n          decodeReply,\n          decodeReplyFromBusboy,\n          decodeAction,\n          decodeFormState,\n        } = require(\n          `./react-server.node`\n        ) as typeof import('./react-server.node')\n\n        temporaryReferences = createTemporaryReferenceSet()\n\n        const { Transform } =\n          require('node:stream') as typeof import('node:stream')\n\n        const defaultBodySizeLimit = '1 MB'\n        const bodySizeLimit =\n          serverActions?.bodySizeLimit ?? defaultBodySizeLimit\n        const bodySizeLimitBytes =\n          bodySizeLimit !== defaultBodySizeLimit\n            ? (\n                require('next/dist/compiled/bytes') as typeof import('bytes')\n              ).parse(bodySizeLimit)\n            : 1024 * 1024 // 1 MB\n\n        let size = 0\n        const body = req.body.pipe(\n          new Transform({\n            transform(chunk, encoding, callback) {\n              size += Buffer.byteLength(chunk, encoding)\n              if (size > bodySizeLimitBytes) {\n                const { ApiError } = require('../api-utils')\n\n                callback(\n                  new ApiError(\n                    413,\n                    `Body exceeded ${bodySizeLimit} limit.\n                To configure the body size limit for Server Actions, see: https://nextjs.org/docs/app/api-reference/next-config-js/serverActions#bodysizelimit`\n                  )\n                )\n                return\n              }\n\n              callback(null, chunk)\n            },\n          })\n        )\n\n        if (isMultipartAction) {\n          if (isFetchAction) {\n            try {\n              actionModId = getActionModIdOrError(actionId, serverModuleMap)\n            } catch (err) {\n              console.warn(err)\n\n              return {\n                type: 'not-found',\n              }\n            }\n\n            const busboy = (require('busboy') as typeof import('busboy'))({\n              defParamCharset: 'utf8',\n              headers: req.headers,\n              limits: { fieldSize: bodySizeLimitBytes },\n            })\n\n            body.pipe(busboy)\n\n            boundActionArguments = await decodeReplyFromBusboy(\n              busboy,\n              serverModuleMap,\n              { temporaryReferences }\n            )\n          } else {\n            // React doesn't yet publish a busboy version of decodeAction\n            // so we polyfill the parsing of FormData.\n            const fakeRequest = new Request('http://localhost', {\n              method: 'POST',\n              // @ts-expect-error\n              headers: { 'Content-Type': contentType },\n              body: new ReadableStream({\n                start: (controller) => {\n                  body.on('data', (chunk) => {\n                    controller.enqueue(new Uint8Array(chunk))\n                  })\n                  body.on('end', () => {\n                    controller.close()\n                  })\n                  body.on('error', (err) => {\n                    controller.error(err)\n                  })\n                },\n              }),\n              duplex: 'half',\n            })\n            const formData = await fakeRequest.formData()\n\n            if (areAllActionIdsValid(formData, serverModuleMap) === false) {\n              // TODO: This can be from skew or manipulated input. We should handle this case\n              // more gracefully but this preserves the prior behavior where decodeAction would throw instead.\n              throw new Error(\n                `Failed to find Server Action. This request might be from an older or newer deployment.\\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n              )\n            }\n\n            // TODO: Refactor so it is harder to accidentally decode an action before you have validated that the\n            // action referred to is available.\n            const action = await decodeAction(formData, serverModuleMap)\n            if (typeof action === 'function') {\n              // Only warn if it's a server action, otherwise skip for other post requests\n              warnBadServerActionRequest()\n              const actionReturnedState = await action()\n              formState = await decodeFormState(\n                actionReturnedState,\n                formData,\n                serverModuleMap\n              )\n            }\n\n            // Skip the fetch path\n            return\n          }\n        } else {\n          try {\n            actionModId = getActionModIdOrError(actionId, serverModuleMap)\n          } catch (err) {\n            if (actionId !== null) {\n              console.error(err)\n            }\n            return {\n              type: 'not-found',\n            }\n          }\n\n          const chunks: Buffer[] = []\n          for await (const chunk of req.body) {\n            chunks.push(Buffer.from(chunk))\n          }\n\n          const actionData = Buffer.concat(chunks).toString('utf-8')\n\n          boundActionArguments = await decodeReply(\n            actionData,\n            serverModuleMap,\n            { temporaryReferences }\n          )\n        }\n      } else {\n        throw new Error('Invariant: Unknown request type.')\n      }\n\n      // actions.js\n      // app/page.js\n      //   action worker1\n      //     appRender1\n\n      // app/foo/page.js\n      //   action worker2\n      //     appRender\n\n      // / -> fire action -> POST / -> appRender1 -> modId for the action file\n      // /foo -> fire action -> POST /foo -> appRender2 -> modId for the action file\n\n      try {\n        actionModId =\n          actionModId ?? getActionModIdOrError(actionId, serverModuleMap)\n      } catch (err) {\n        if (actionId !== null) {\n          console.error(err)\n        }\n        return {\n          type: 'not-found',\n        }\n      }\n\n      const actionHandler = (\n        await ComponentMod.__next_app__.require(actionModId)\n      )[\n        // `actionId` must exist if we got here, as otherwise we would have thrown an error above\n        actionId!\n      ]\n\n      const returnVal = await workUnitAsyncStorage.run(requestStore, () =>\n        actionHandler.apply(null, boundActionArguments)\n      )\n\n      // For form actions, we need to continue rendering the page.\n      if (isFetchAction) {\n        await addRevalidationHeader(res, {\n          workStore,\n          requestStore,\n        })\n\n        actionResult = await finalizeAndGenerateFlight(req, ctx, requestStore, {\n          actionResult: Promise.resolve(returnVal),\n          // if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree\n          skipFlight: !workStore.pathWasRevalidated || actionWasForwarded,\n          temporaryReferences,\n        })\n      }\n    })\n\n    return {\n      type: 'done',\n      result: actionResult,\n      formState,\n    }\n  } catch (err) {\n    if (isRedirectError(err)) {\n      const redirectUrl = getURLFromRedirectError(err)\n      const redirectType = getRedirectTypeFromError(err)\n\n      await addRevalidationHeader(res, {\n        workStore,\n        requestStore,\n      })\n\n      // if it's a fetch action, we'll set the status code for logging/debugging purposes\n      // but we won't set a Location header, as the redirect will be handled by the client router\n      res.statusCode = RedirectStatusCode.SeeOther\n\n      if (isFetchAction) {\n        return {\n          type: 'done',\n          result: await createRedirectRenderResult(\n            req,\n            res,\n            host,\n            redirectUrl,\n            redirectType,\n            ctx.renderOpts.basePath,\n            workStore\n          ),\n        }\n      }\n\n      // If there were mutable cookies set, we need to set them on the\n      // response.\n      const headers = new Headers()\n      if (appendMutableCookies(headers, requestStore.mutableCookies)) {\n        res.setHeader('set-cookie', Array.from(headers.values()))\n      }\n\n      res.setHeader('Location', redirectUrl)\n      return {\n        type: 'done',\n        result: RenderResult.fromStatic(''),\n      }\n    } else if (isHTTPAccessFallbackError(err)) {\n      res.statusCode = getAccessFallbackHTTPStatus(err)\n\n      await addRevalidationHeader(res, {\n        workStore,\n        requestStore,\n      })\n\n      if (isFetchAction) {\n        const promise = Promise.reject(err)\n        try {\n          // we need to await the promise to trigger the rejection early\n          // so that it's already handled by the time we call\n          // the RSC runtime. Otherwise, it will throw an unhandled\n          // promise rejection error in the renderer.\n          await promise\n        } catch {\n          // swallow error, it's gonna be handled on the client\n        }\n        return {\n          type: 'done',\n          result: await finalizeAndGenerateFlight(req, ctx, requestStore, {\n            skipFlight: false,\n            actionResult: promise,\n            temporaryReferences,\n          }),\n        }\n      }\n      return {\n        type: 'not-found',\n      }\n    }\n\n    if (isFetchAction) {\n      res.statusCode = 500\n      await Promise.all([\n        workStore.incrementalCache?.revalidateTag(\n          workStore.revalidatedTags || []\n        ),\n        ...Object.values(workStore.pendingRevalidates || {}),\n        ...(workStore.pendingRevalidateWrites || []),\n      ])\n      const promise = Promise.reject(err)\n      try {\n        // we need to await the promise to trigger the rejection early\n        // so that it's already handled by the time we call\n        // the RSC runtime. Otherwise, it will throw an unhandled\n        // promise rejection error in the renderer.\n        await promise\n      } catch {\n        // swallow error, it's gonna be handled on the client\n      }\n\n      requestStore.phase = 'render'\n      return {\n        type: 'done',\n        result: await generateFlight(req, ctx, requestStore, {\n          actionResult: promise,\n          // if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree\n          skipFlight: !workStore.pathWasRevalidated || actionWasForwarded,\n          temporaryReferences,\n        }),\n      }\n    }\n\n    throw err\n  }\n}\n\n/**\n * Attempts to find the module ID for the action from the module map. When this fails, it could be a deployment skew where\n * the action came from a different deployment. It could also simply be an invalid POST request that is not a server action.\n * In either case, we'll throw an error to be handled by the caller.\n */\nfunction getActionModIdOrError(\n  actionId: string | null,\n  serverModuleMap: ServerModuleMap\n): string {\n  try {\n    // if we're missing the action ID header, we can't do any further processing\n    if (!actionId) {\n      throw new Error(\"Invariant: Missing 'next-action' header.\")\n    }\n\n    const actionModId = serverModuleMap?.[actionId]?.id\n\n    if (!actionModId) {\n      throw new Error(\n        \"Invariant: Couldn't find action module ID from module map.\"\n      )\n    }\n\n    return actionModId\n  } catch (err) {\n    throw getActionNotFoundError(actionId, err as Error)\n  }\n}\n\nfunction getActionNotFoundError(actionId: string | null, err?: Error): Error {\n  return new Error(\n    `Failed to find Server Action${actionId ? ` \"${actionId}\"` : ''}. This request might be from an older or newer deployment. ${\n      err instanceof Error ? `Original error: ${err.message}` : ''\n    }`\n  )\n}\n\nconst $ACTION_ = '$ACTION_'\nconst $ACTION_REF_ = '$ACTION_REF_'\nconst $ACTION_ID_ = '$ACTION_ID_'\nconst ACTION_ID_EXPECTED_LENGTH = 42\n\n/**\n * This function mirrors logic inside React's decodeAction and should be kept in sync with that.\n * It pre-parses the FormData to ensure that any action IDs referred to are actual action IDs for\n * this Next.js application.\n */\nfunction areAllActionIdsValid(\n  mpaFormData: FormData,\n  serverModuleMap: ServerModuleMap\n): boolean {\n  let hasAtLeastOneAction = false\n  // Before we attempt to decode the payload for a possible MPA action, assert that all\n  // action IDs are valid IDs. If not we should disregard the payload\n  for (let key of mpaFormData.keys()) {\n    if (!key.startsWith($ACTION_)) {\n      // not a relevant field\n      continue\n    }\n\n    if (key.startsWith($ACTION_ID_)) {\n      // No Bound args case\n      if (isInvalidActionIdFieldName(key, serverModuleMap)) {\n        return false\n      }\n\n      hasAtLeastOneAction = true\n    } else if (key.startsWith($ACTION_REF_)) {\n      // Bound args case\n      const actionDescriptorField =\n        $ACTION_ + key.slice($ACTION_REF_.length) + ':0'\n      const actionFields = mpaFormData.getAll(actionDescriptorField)\n      if (actionFields.length !== 1) {\n        return false\n      }\n      const actionField = actionFields[0]\n      if (typeof actionField !== 'string') {\n        return false\n      }\n\n      if (isInvalidStringActionDescriptor(actionField, serverModuleMap)) {\n        return false\n      }\n      hasAtLeastOneAction = true\n    }\n  }\n  return hasAtLeastOneAction\n}\n\nconst ACTION_DESCRIPTOR_ID_PREFIX = '{\"id\":\"'\nfunction isInvalidStringActionDescriptor(\n  actionDescriptor: string,\n  serverModuleMap: ServerModuleMap\n): unknown {\n  if (actionDescriptor.startsWith(ACTION_DESCRIPTOR_ID_PREFIX) === false) {\n    return true\n  }\n\n  const from = ACTION_DESCRIPTOR_ID_PREFIX.length\n  const to = from + ACTION_ID_EXPECTED_LENGTH\n\n  // We expect actionDescriptor to be '{\"id\":\"<actionId>\",...}'\n  const actionId = actionDescriptor.slice(from, to)\n  if (\n    actionId.length !== ACTION_ID_EXPECTED_LENGTH ||\n    actionDescriptor[to] !== '\"'\n  ) {\n    return true\n  }\n\n  const entry = serverModuleMap[actionId]\n\n  if (entry == null) {\n    return true\n  }\n\n  return false\n}\n\nfunction isInvalidActionIdFieldName(\n  actionIdFieldName: string,\n  serverModuleMap: ServerModuleMap\n): boolean {\n  // The field name must always start with $ACTION_ID_ but since it is\n  // the id is extracted from the key of the field we have already validated\n  // this before entering this function\n  if (\n    actionIdFieldName.length !==\n    $ACTION_ID_.length + ACTION_ID_EXPECTED_LENGTH\n  ) {\n    // this field name has too few or too many characters\n    return true\n  }\n\n  const actionId = actionIdFieldName.slice($ACTION_ID_.length)\n  const entry = serverModuleMap[actionId]\n\n  if (entry == null) {\n    return true\n  }\n\n  return false\n}\n"],"names":["RSC_HEADER","RSC_CONTENT_TYPE_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","ACTION_HEADER","getAccessFallbackHTTPStatus","isHTTPAccessFallbackError","getRedirectTypeFromError","getURLFromRedirectError","isRedirectError","RenderResult","FlightRenderResult","filterReqHeaders","actionsForbiddenHeaders","appendMutableCookies","getModifiedCookieValues","NEXT_CACHE_REVALIDATED_TAGS_HEADER","NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER","getServerActionRequestMetadata","isCsrfOriginAllowed","warn","RequestCookies","ResponseCookies","HeadersAdapter","fromNodeOutgoingHttpHeaders","selectWorkerForForwarding","isNodeNextRequest","isWebNextRequest","RedirectStatusCode","synchronizeMutableCookies","workUnitAsyncStorage","hasServerActions","manifest","Object","keys","node","length","edge","nodeHeadersToRecord","headers","record","key","value","entries","undefined","Array","isArray","join","getForwardedHeaders","req","res","requestHeaders","requestCookies","from","responseHeaders","getHeaders","responseCookies","mergedHeaders","getAll","forEach","cookie","delete","name","set","toString","Headers","addRevalidationHeader","workStore","requestStore","Promise","all","incrementalCache","revalidateTag","revalidatedTags","values","pendingRevalidates","pendingRevalidateWrites","isTagRevalidated","isCookieRevalidated","mutableCookies","setHeader","JSON","stringify","createForwardedActionResponse","host","workerPathname","basePath","Error","forwardedHeaders","proto","requestProtocol","origin","process","env","__NEXT_PRIVATE_ORIGIN","fetchUrl","URL","response","body","NEXT_RUNTIME","stream","fetch","method","duplex","redirect","next","internal","get","startsWith","includes","cancel","err","console","error","fromStatic","getAppRelativeRedirectUrl","redirectUrl","parsedRedirectUrl","pathname","createRedirectRenderResult","originalHost","redirectType","appRelativeRedirectUrl","search","prerenderManifest","preview","previewModeId","limitUntrustedHeaderValueForLogs","slice","handleAction","ComponentMod","serverModuleMap","generateFlight","serverActions","ctx","contentType","serverActionsManifest","page","renderOpts","actionId","isURLEncodedAction","isMultipartAction","isFetchAction","isServerAction","type","getActionNotFoundError","isStaticGeneration","temporaryReferences","finalizeAndGenerateFlight","args","phase","fetchCache","originDomain","forwardedHostHeader","hostHeader","warning","warnBadServerActionRequest","allowedOrigins","statusCode","promise","reject","result","actionResult","skipFlight","pathWasRevalidated","boundActionArguments","actionAsyncStorage","formState","actionModId","actionWasForwarded","Boolean","forwardedWorker","run","isAction","createTemporaryReferenceSet","decodeReply","decodeAction","decodeFormState","formData","request","getActionModIdOrError","areAllActionIdsValid","action","actionReturnedState","actionData","reader","getReader","done","read","TextDecoder","decode","decodeReplyFromBusboy","require","Transform","defaultBodySizeLimit","bodySizeLimit","bodySizeLimitBytes","parse","size","pipe","transform","chunk","encoding","callback","Buffer","byteLength","ApiError","busboy","defParamCharset","limits","fieldSize","fakeRequest","Request","ReadableStream","start","controller","on","enqueue","Uint8Array","close","chunks","push","concat","actionHandler","__next_app__","returnVal","apply","resolve","SeeOther","id","message","$ACTION_","$ACTION_REF_","$ACTION_ID_","ACTION_ID_EXPECTED_LENGTH","mpaFormData","hasAtLeastOneAction","isInvalidActionIdFieldName","actionDescriptorField","actionFields","actionField","isInvalidStringActionDescriptor","ACTION_DESCRIPTOR_ID_PREFIX","actionDescriptor","to","entry","actionIdFieldName"],"mappings":"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"}